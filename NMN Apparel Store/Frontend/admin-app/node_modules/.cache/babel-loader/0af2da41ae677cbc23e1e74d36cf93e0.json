{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsParens = needsParens;\n\nvar whitespace = _interopRequireWildcard(require(\"./whitespace\"));\n\nvar parens = _interopRequireWildcard(require(\"./parentheses\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = t.FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nconst expandedWhitespaceList = expandAliases(whitespace.list);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (t.isCallExpression(node)) {\n    return true;\n  }\n\n  return t.isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return 0;\n\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  let linesInfo = find(expandedWhitespaceNodes, node, parent);\n\n  if (!linesInfo) {\n    const items = find(expandedWhitespaceList, node, parent);\n\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        linesInfo = needsWhitespace(items[i], node, type);\n        if (linesInfo) break;\n      }\n    }\n  }\n\n  if (typeof linesInfo === \"object\" && linesInfo !== null) {\n    return linesInfo[type] || 0;\n  }\n\n  return 0;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, \"before\");\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, \"after\");\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (t.isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}","map":{"version":3,"sources":["/Users/nidhigupta/Desktop/NMN Apparel Store/Frontend/admin-app/node_modules/@babel/generator/lib/node/index.js"],"names":["Object","defineProperty","exports","value","needsWhitespace","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","whitespace","_interopRequireWildcard","require","parens","t","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","expandAliases","add","type","func","fn","node","parent","stack","result","keys","aliases","FLIPPED_ALIAS_KEYS","alias","expandedParens","expandedWhitespaceNodes","nodes","expandedWhitespaceList","list","find","printStack","isOrHasCallExpression","isCallExpression","isMemberExpression","object","isExpressionStatement","expression","linesInfo","items","i","length","isNewExpression","callee"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAF,OAAO,CAACG,qBAAR,GAAgCA,qBAAhC;AACAH,OAAO,CAACI,oBAAR,GAA+BA,oBAA/B;AACAJ,OAAO,CAACK,WAAR,GAAsBA,WAAtB;;AAEA,IAAIC,UAAU,GAAGC,uBAAuB,CAACC,OAAO,CAAC,cAAD,CAAR,CAAxC;;AAEA,IAAIC,MAAM,GAAGF,uBAAuB,CAACC,OAAO,CAAC,eAAD,CAAR,CAApC;;AAEA,IAAIE,CAAC,GAAGH,uBAAuB,CAACC,OAAO,CAAC,cAAD,CAAR,CAA/B;;AAEA,SAASG,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,YAAY;AAAE,WAAOE,KAAP;AAAe,GAAxD;;AAA0D,SAAOA,KAAP;AAAe;;AAE1L,SAASN,uBAAT,CAAiCO,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa;;AAAC,MAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;AAAE,WAAO;AAAEE,MAAAA,OAAO,EAAEF;AAAX,KAAP;AAA0B;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACI,GAAN,CAAUH,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACK,GAAN,CAAUJ,GAAV,CAAP;AAAwB;;AAAC,MAAIK,MAAM,GAAG,EAAb;AAAiB,MAAIC,qBAAqB,GAAGtB,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACuB,wBAA5D;;AAAsF,OAAK,IAAIC,GAAT,IAAgBR,GAAhB,EAAqB;AAAE,QAAIhB,MAAM,CAACyB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCX,GAArC,EAA0CQ,GAA1C,CAAJ,EAAoD;AAAE,UAAII,IAAI,GAAGN,qBAAqB,GAAGtB,MAAM,CAACuB,wBAAP,CAAgCP,GAAhC,EAAqCQ,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,UAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAE7B,QAAAA,MAAM,CAACC,cAAP,CAAsBoB,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AAA2C,OAAjF,MAAuF;AAAEP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcR,GAAG,CAACQ,GAAD,CAAjB;AAAyB;AAAE;AAAE;;AAACH,EAAAA,MAAM,CAACH,OAAP,GAAiBF,GAAjB;;AAAsB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACc,GAAN,CAAUb,GAAV,EAAeK,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAEvuB,SAASS,aAAT,CAAuBd,GAAvB,EAA4B;AAC1B,QAAMK,MAAM,GAAG,EAAf;;AAEA,WAASU,GAAT,CAAaC,IAAb,EAAmBC,IAAnB,EAAyB;AACvB,UAAMC,EAAE,GAAGb,MAAM,CAACW,IAAD,CAAjB;AACAX,IAAAA,MAAM,CAACW,IAAD,CAAN,GAAeE,EAAE,GAAG,UAAUC,IAAV,EAAgBC,MAAhB,EAAwBC,KAAxB,EAA+B;AACjD,YAAMC,MAAM,GAAGJ,EAAE,CAACC,IAAD,EAAOC,MAAP,EAAeC,KAAf,CAAjB;AACA,aAAOC,MAAM,IAAI,IAAV,GAAiBL,IAAI,CAACE,IAAD,EAAOC,MAAP,EAAeC,KAAf,CAArB,GAA6CC,MAApD;AACD,KAHgB,GAGbL,IAHJ;AAID;;AAED,OAAK,MAAMD,IAAX,IAAmBhC,MAAM,CAACuC,IAAP,CAAYvB,GAAZ,CAAnB,EAAqC;AACnC,UAAMwB,OAAO,GAAG5B,CAAC,CAAC6B,kBAAF,CAAqBT,IAArB,CAAhB;;AAEA,QAAIQ,OAAJ,EAAa;AACX,WAAK,MAAME,KAAX,IAAoBF,OAApB,EAA6B;AAC3BT,QAAAA,GAAG,CAACW,KAAD,EAAQ1B,GAAG,CAACgB,IAAD,CAAX,CAAH;AACD;AACF,KAJD,MAIO;AACLD,MAAAA,GAAG,CAACC,IAAD,EAAOhB,GAAG,CAACgB,IAAD,CAAV,CAAH;AACD;AACF;;AAED,SAAOX,MAAP;AACD;;AAED,MAAMsB,cAAc,GAAGb,aAAa,CAACnB,MAAD,CAApC;AACA,MAAMiC,uBAAuB,GAAGd,aAAa,CAACtB,UAAU,CAACqC,KAAZ,CAA7C;AACA,MAAMC,sBAAsB,GAAGhB,aAAa,CAACtB,UAAU,CAACuC,IAAZ,CAA5C;;AAEA,SAASC,IAAT,CAAchC,GAAd,EAAmBmB,IAAnB,EAAyBC,MAAzB,EAAiCa,UAAjC,EAA6C;AAC3C,QAAMf,EAAE,GAAGlB,GAAG,CAACmB,IAAI,CAACH,IAAN,CAAd;AACA,SAAOE,EAAE,GAAGA,EAAE,CAACC,IAAD,EAAOC,MAAP,EAAea,UAAf,CAAL,GAAkC,IAA3C;AACD;;AAED,SAASC,qBAAT,CAA+Bf,IAA/B,EAAqC;AACnC,MAAIvB,CAAC,CAACuC,gBAAF,CAAmBhB,IAAnB,CAAJ,EAA8B;AAC5B,WAAO,IAAP;AACD;;AAED,SAAOvB,CAAC,CAACwC,kBAAF,CAAqBjB,IAArB,KAA8Be,qBAAqB,CAACf,IAAI,CAACkB,MAAN,CAA1D;AACD;;AAED,SAASjD,eAAT,CAAyB+B,IAAzB,EAA+BC,MAA/B,EAAuCJ,IAAvC,EAA6C;AAC3C,MAAI,CAACG,IAAL,EAAW,OAAO,CAAP;;AAEX,MAAIvB,CAAC,CAAC0C,qBAAF,CAAwBnB,IAAxB,CAAJ,EAAmC;AACjCA,IAAAA,IAAI,GAAGA,IAAI,CAACoB,UAAZ;AACD;;AAED,MAAIC,SAAS,GAAGR,IAAI,CAACJ,uBAAD,EAA0BT,IAA1B,EAAgCC,MAAhC,CAApB;;AAEA,MAAI,CAACoB,SAAL,EAAgB;AACd,UAAMC,KAAK,GAAGT,IAAI,CAACF,sBAAD,EAAyBX,IAAzB,EAA+BC,MAA/B,CAAlB;;AAEA,QAAIqB,KAAJ,EAAW;AACT,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrCF,QAAAA,SAAS,GAAGpD,eAAe,CAACqD,KAAK,CAACC,CAAD,CAAN,EAAWvB,IAAX,EAAiBH,IAAjB,CAA3B;AACA,YAAIwB,SAAJ,EAAe;AAChB;AACF;AACF;;AAED,MAAI,OAAOA,SAAP,KAAqB,QAArB,IAAiCA,SAAS,KAAK,IAAnD,EAAyD;AACvD,WAAOA,SAAS,CAACxB,IAAD,CAAT,IAAmB,CAA1B;AACD;;AAED,SAAO,CAAP;AACD;;AAED,SAAS3B,qBAAT,CAA+B8B,IAA/B,EAAqCC,MAArC,EAA6C;AAC3C,SAAOhC,eAAe,CAAC+B,IAAD,EAAOC,MAAP,EAAe,QAAf,CAAtB;AACD;;AAED,SAAS9B,oBAAT,CAA8B6B,IAA9B,EAAoCC,MAApC,EAA4C;AAC1C,SAAOhC,eAAe,CAAC+B,IAAD,EAAOC,MAAP,EAAe,OAAf,CAAtB;AACD;;AAED,SAAS7B,WAAT,CAAqB4B,IAArB,EAA2BC,MAA3B,EAAmCa,UAAnC,EAA+C;AAC7C,MAAI,CAACb,MAAL,EAAa,OAAO,KAAP;;AAEb,MAAIxB,CAAC,CAACgD,eAAF,CAAkBxB,MAAlB,KAA6BA,MAAM,CAACyB,MAAP,KAAkB1B,IAAnD,EAAyD;AACvD,QAAIe,qBAAqB,CAACf,IAAD,CAAzB,EAAiC,OAAO,IAAP;AAClC;;AAED,SAAOa,IAAI,CAACL,cAAD,EAAiBR,IAAjB,EAAuBC,MAAvB,EAA+Ba,UAA/B,CAAX;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsParens = needsParens;\n\nvar whitespace = _interopRequireWildcard(require(\"./whitespace\"));\n\nvar parens = _interopRequireWildcard(require(\"./parentheses\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = t.FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nconst expandedWhitespaceList = expandAliases(whitespace.list);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (t.isCallExpression(node)) {\n    return true;\n  }\n\n  return t.isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return 0;\n\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  let linesInfo = find(expandedWhitespaceNodes, node, parent);\n\n  if (!linesInfo) {\n    const items = find(expandedWhitespaceList, node, parent);\n\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        linesInfo = needsWhitespace(items[i], node, type);\n        if (linesInfo) break;\n      }\n    }\n  }\n\n  if (typeof linesInfo === \"object\" && linesInfo !== null) {\n    return linesInfo[type] || 0;\n  }\n\n  return 0;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, \"before\");\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, \"after\");\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (t.isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}"]},"metadata":{},"sourceType":"script"}