{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["/Users/nidhigupta/Desktop/NMN Apparel Store/Frontend/admin-app/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","types","checkPath","path","opts","node","parent","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","parentPath","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","scope","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}